\documentclass{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{pdfpages}

\graphicspath{{./LatexImg/}}

\begin{document}
	
	\includepdf{CoverPage.pdf}
	
	First and foremost, the programming language used to conduct this lab is Python 3.7, and the libraries primarily used are opencv2, numpy, math and matplotlib. In addition, the coloured channels in python are represented in a BGR order when importing images through opencv2. To view the cover page if it doesn't display properly, open \textbf{CoverPage.pdf} included in the folder provided.\\
	
	\section{Introduction}
	
	This lab examines the concept of coloured images and the importance of understanding their properties when processing such an image. A grayscale image is an represented as an array with values at each pixel location, indicating an intensity value. The grayscale image can be thought of as a single channel image. Unlike a grayscale image, a coloured one has an ordered set of values, represented by 3 channels with the values pertaining to the red, green and blue intensities, shown in Equation 1 below.
	
	\begin{equation}
		\vec{I}(x,y) = \Big( r(x,y),g(x,y),b(x,y) \Big)
	\end{equation}
	
	A coloured image can be thought of as a vector as each of the channels are deemed separate and thus can represent the image in a vector space as each colour channel can represent a coordinate in a Cartesian space.\\
	
	When observing a coloured image as a grayscale, the collective intensities of the three channels are used to calculate the brightness of the image. However, the three channels aren't perceived equally by the human eye. The human eye perceives the colour green more acute than either red or blue. Therefore, the colour green has more weight when calculating brightness than the other two channels. The equation for converting the coloured images to a grayscale intensity image is shown below in equation 2.\\
	
	\begin{equation}
		I_{g}(x,y) = 0.299r(x,y) + 0.587g(x,y) + 0.114b(x,y)
	\end{equation}
	
	\section{Colour Spaces and Transformation}
	
	Transforming a coloured image is an important concept in image processing as the perception of the properties of an image does not correlate with the RGB representation of colour. A new representation of a colour space is needed to modify the image in a manner where the result is much more clear when apply a simple transform.\\
	
	A colour transformation function takes a vector, $\vec{c} = (r,g,b),$ which represents a pixel in the RGB colour space and transforms it to a new vector in another space, $\vec{c}_{T}$, by\\
	
	\begin{equation}
		\vec{c}_T = T(\vec{c}),
	\end{equation}
	
	where $T$ is the transformation function. Consequently, to convert back to the original colour space, an inverse function, $T^{-1}$, is applied to the transformed vector,\\
	
	\begin{equation}
	\vec{c} = T^{-1}(\vec{c}_{T}),
	\end{equation}
	
	\subsection{HSI}
	
	HSI representation uses the three channels to signify Hue, Saturation and Intensity. This represents a vector using cylindrical coordinates. Hue is the angular position of the colour, which decides the colour of the pixel. Saturation is the distance from the origin on the circular plane which represents the depth of the colour selected by the Hue. Intensity determines the brightness of the pixel, therefore whether the image is perceived as light or dark. Below is a photo of the HSI colour space.\\
	
	 \begin{center}
	 	\noindent \includegraphics[scale=1.25]{HSI}\\
	 	Image 1: HSI Colour Space Representation\\
	 \end{center}
	
	To convert from RGB to HSI colour model, the following non linear model was used in this investigation.\\
	
	\begin{equation}
		H = \begin{cases} 
		\theta, & \textrm{if}\ b \leq g\\
		2\pi - \theta, & \textrm{if}\ b > g
		\end{cases}
	\end{equation}
	
	\begin{equation}
		\theta = \textrm{cos}^{-1}\left(  \frac{[(r-g) + (r-b)]}{2\sqrt{(r-g)^{2} + (r-b)(g-b)}} \right)
	\end{equation}
	
	\begin{equation}
		S = 1 - \left[ \frac{3}{r+ g+ b} \right]c_{min}
	\end{equation}
	
	\begin{equation}
		c_{min} = min(r,g,b)
	\end{equation}
	
	\begin{equation}
		I = \frac{r + b + g}{3}
	\end{equation}
	
	These equation presume that the values of the pixels are between the values of 0 and 1. The output of the Hue value will be between 0 and $2\pi$, while Saturation and Intensity are between 0 and 1.\\
	
	The inverse transformation function is more complicated than the previous definition as it correlates with the value of Hue. The transformation is modelled below.\\
	
	If $0 \leq H < \frac{2}{3}\pi$(red-green region) then

	\begin{equation}
		b = I(1 - S)
	\end{equation}
	
	\begin{equation}
		r = I\left[1 + \frac{S\textrm{cos}(H)}{\textrm{cos}(\frac{\pi}{3} - H)}\right]
	\end{equation}
	
	\begin{equation}
		g = 3I - (r + b)
	\end{equation}
	
	If $\frac{2}{3}\pi \leq H < \frac{4}{3}\pi$(green-blue region) then
	
	\begin{equation}
	r = I(1 - S)
	\end{equation}
	
	\begin{equation}
	g = I\left[1 + \frac{S\textrm{cos}(H - \frac{2}{3}\pi)}{\textrm{cos}(\pi - H)}\right]
	\end{equation}
	
	\begin{equation}
	b = 3I - (r + g)
	\end{equation}
	
	If $\frac{4}{3}\pi \leq H < 2\pi$(blue-red region) then
	
	\begin{equation}
	g = I(1 - S)
	\end{equation}
	
	\begin{equation}
	b = I\left[1 + \frac{S\textrm{cos}(H - \frac{4}{3}\pi)}{\textrm{cos}(\frac{5\pi}{3} - H)}\right]
	\end{equation}
	
	\begin{equation}
	r = 3I - (b + g)
	\end{equation}
	
	This setup is used due to the primary colour values (red,green,blue) regions overlapping in the colour space due to the Hue.
	
	\subsection{YUV}
	
	The YUV colour space is similar to the HSI colour space in which it transforms a colour space through a function. For this lab, the vector space used is the RGB space and the YUV variant is the JPEG $\textrm{Y}^\prime$CbCr.\\
	
	The YUV colour space uses three channels, but the channels are split into two categories, Luma, ($\textrm{Y}^\prime$) and Chroma (Cb and Cr). Luma is the apparent brightness of the image, or in the case of grayscale, is the intensity of the image. Chroma represents the colour information of the image. The Cb and Cr channels are the blue-difference and red-difference chroma components, respectively.\\
	
	Considering an RGB colour vector $\vec{c}$,\\
	
		\begin{align}
			y &= \begin{bmatrix}
			r \\
			g \\
			g
			\end{bmatrix},
		\end{align}
	
	we apply the following linear transformations on the RGB colour space to convert to the $\textrm{Y}^\prime$ CbCr space.\\
	
	\begin{align}
		\begin{bmatrix}
			Y^\prime \\
			Cb \\
			Cr
			\end{bmatrix}
			= 	
		\begin{bmatrix}
			0.299 & 0.587 & 0.114\\
			-0.1687 & -0.3313 & 0.5\\
			0.5 & -0.4187 & -0.0813
		\end{bmatrix}
		%
		\begin{bmatrix}
		r \\
		g \\
		b
		\end{bmatrix}
		+
		\begin{bmatrix}
		0 \\
		128 \\
		128
		\end{bmatrix}
	\end{align}
	
	This is a linear transformation by stretching the RGB cube by rotating, scaling and translating it in a Cartesian space, transforming it into a new cube. Since this is a linear transformation, multiplying by the inverse transformation matrix.\\
	
	\begin{align}
		\begin{bmatrix}
			r \\
			g \\
			b
		\end{bmatrix}
		= 	
		\begin{bmatrix}
			1 & 0 & 1.402\\
			1 & -0.34414 & -0.71414\\
			1 & 1.772 & 0
		\end{bmatrix}
		%
		\left(
			\begin{bmatrix}
				Y^\prime \\
				Cb \\
				Cr
			\end{bmatrix}
			-
			\begin{bmatrix}
				0 \\
				128 \\
				128
			\end{bmatrix}
		\right)
	\end{align} 
	
	If the image is of type double, and the RGB or $\textrm{Y}^\prime$CbCr values are between 0 and 1, then the offsets are not needed. These equations are exactly the same except for the offset values. These matrices transformation are shown below.\\
	
	\begin{align}
		\begin{bmatrix}
			Y^\prime \\
			Cb \\
			Cr
		\end{bmatrix}
		= 	
		\begin{bmatrix}
			0.299 & 0.587 & 0.114\\
			-0.1687 & -0.3313 & 0.5\\
			0.5 & -0.4187 & -0.0813
		\end{bmatrix}
		%
		\begin{bmatrix}
			r \\
			g \\
			b
		\end{bmatrix}
	\end{align}
	
	\begin{align}
		\begin{bmatrix}
			r \\
			g \\
			b
		\end{bmatrix}
		= 	
		\begin{bmatrix}
			1 & 0 & 1.402\\
			1 & -0.34414 & -0.71414\\
			1 & 1.772 & 0
		\end{bmatrix}
		%
		\begin{bmatrix}
			Y^\prime \\
			Cb \\
			Cr
		\end{bmatrix}
	\end{align} 
	
	\section{Assignment}
	
	\subsection{Colour Space Conversion}
	
	\subsubsection{RGB to HSI}
	
	This is an implementation of the function described in equations 5 through 9. This implementation divides each pixel channel value by 255 to ensure each value is between 0 and 1, and converts the output image to type double.

	\subsubsection{HSI to RGB}
		
	This is an implementation of the method described in equations 10 through 18 to convert the image from the HSI colour space to RGB channels. This implementation was done with conditional statements to emulate the colour regions.\\
	
	\subsubsection{RGB to $\textrm{Y}^\prime$CbCr}
	
	This function converts the RGB colour space to a $\textrm{Y}^\prime$CbCr colour space. This is done through a transformation matrix operator shown in equation 20 and 22 for unsigned 8-bit integer and double respectively.\\
	
	\subsubsection{$\textrm{Y}^\prime$CbCr to RGB}
	
	This function is the inverse of the function described above where it converts $\textrm{Y}^\prime$CbCr to a RGB colour space. As mentioned above there are two conversions, one for unsigned char and the other for double shown in equations 21 and 23 respectively.\\
	
	
	
	\subsection{Colour Processing}
	
	
	\subsubsection{Change Hue}
	
	This function rotates the vector around the hue to manipulate the colours of every pixel found in the photo, instead of adjusting their individual RGB channels. This function converts the RGB image to a HSI model, then adds the input value to the Hue, and finally converts the image back to the RGB channel. This allows for a much easier and smoother transformation of colour than RGB operations.\\
	
	\subsubsection{Change Saturation}
	
	This function adjusts the richness of an image by adjusting the Saturation value of an HSI colour image. Firstly, this function converts the RGB image to an HSI colour space, the increases of decreases the Saturation value to every pixel, and then converts the value back to a RGB colour image.\\

	\subsubsection{Point Transform}

	The Point Transform function from Lab 1 was modified to apply the transformation to each channel individually. This was done by iterating through the image three times, by changing the channel each iteration and using the original function.\\
	
	\subsubsection{Spatial Filter}
	
	The spatial filter function from Lab 2 was modified in a similar manner to the Point Transform function above. Each channel was iterated through individually while applying the transform.\\
	
	\subsubsection{Histogram Equalization - RGB}
	
	The Histogram Equalization function is a modified version of the one done in Lab 3 that accepts RGB coloured images and applies the same methodology as the functions above, by iterating over the image three times while changing the channel of operation each time.\\
	
	\subsubsection{Histogram Equalization - $\textrm{Y}^\prime$CbCr}
	
	This function is similar to the one described above, however the function is only applied to the Luma channel instead of all the channels. This is the exact implementation of the one used in Lab 3 as adjusting the Luma channel is the same as adjusting the intensity on a grayscale image.\\
	
	\section{Analysis}
	
	\begin{enumerate}
		\item Applying the effect to each channel individually does work in certain scenarios, however, since the RGB values aren't directly linked to the colour balance of the image, adjusting those values through histogram equalization may yield drastic or unwanted changes. Applying the operation to the Luma channel, is similar to adjusting the overall brightness of a grayscale image, and thus would adjust the overall brightness of the image while retaining the original colour detail.
		
		\item Since Histogram Equalization is about adjusting the brightness of the overall image, then using the $\textrm{Y}^\prime$CbCr colour space is a more logical choice than the HSI model due to the $\textrm{Y}^\prime$CbCr having an independent colour channel, Luma, which determines the individual brightness of the image. The Intensity channel is not independent of the colour channels as it does not factor in the human eye's bias towards the colour green and treats each intensity as equals as shown in equation 9.
		
		\item When modifying the colour properties of an image, the HSI model is more descriptive when defining the colour of a pixel due to it having two easily identifiable colour channels as opposed to the CbCr channels. Rotating the Hue and adjusting the saturation are directly linked to each colour in the colour space. The CbCr channels do not directly adjust the colour in a simple manner like the HSI model due to the information stored in the channels being more complicated.
		
		\item Run the edge detector from Lab 2 across the three channels to produce three edge images for each colour. Then, use the inclusive or operator to combine the three edge maps like the gradient x and y maps for each of the individual channels.
	\end{enumerate}
	
\end{document}